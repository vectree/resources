# Основы API. Создание собственного API

### Введение

Работая с API, можно испытывать одновременно радость и разочарование. С одной стороны, взаимодействуя с другими приложениями, вы можете сильно увеличить охват аудитории и "вау-эффект" вашего приложения. С другой, это включает в себя чтения тонны документации, изучение стратегий аутентификации и разбор неинформативных (или даже отсутствующих) сообщений об ошибках.

Прежде всего, если вы до сих пор не до конца понимаете, что же такое API (Application Programming Interface - интерфейс программирования приложений), [прочтите объяснение от Skillcrush](http://skillcrush.com/2012/07/04/api-2/), а затем [первую часть этой статьи](http://money.howstuffworks.com/business-communications/how-to-leverage-an-api-for-conferencing1.htm), чтоб наверстать упущенное.

"API" невероятно обширная концепция - каждый раз, когда ваше приложение "общается" с другим приложением, это происходит через некий API. Компоненты внутри вашего собственного приложения, вроде разных частей Rails, также общаются друг с другом через API. Они являются более или менее независимыми субприложениями, которые передают данные, необходимые каждому из них для выполнения собственных специфических задач. В мире приложений все является API!

Когда вы создаете приложения с более динамической фронтенд-функциональностью (как одностраничные Javascript-приложения, так и простые приложения с отдельными AJAX-вызовами), они будут общаться с Rails-бэкендом через ваш собственный API, который в действительности просто дополнительная пара-тройка строк кода, говорящая вашим контроллерам, как отдать JSON или XML вместо HTML.

В этом уроке вы изучите как создать свой собственный API. В последующих уроках мы осветим как взаимодействовать с API других приложений. Уроки должны стать хорошим трамплином для изучения этой темы, но вряд ли смогут полностью охватить все случаи. Большая часть работы с API - это умение читать их документацию и разбираться, чего они от вас хотят.

### Пункты для размышления

_Просмотрите вопросы и проверьте, знаете ли на них ответы. Проверьте себя снова после выполнения задания:_

- Как Rails понимает, какой тип файла вы ожидаете в ответ, когда посылаете HTTP-запрос.
- В чем заключается цель метода `#respond_to`?
- Как вернуть объект пользователя (User), при этом указать атрибуты, которые не хотите включать в этот объект (то есть, вы не можете просто вернуть `User.first`)?
- Назовите 2 шага, выполняемых "за кулисами" метода `#to_json`.
- Как указать действию контроллера, что требуется рендерить лишь сообщение об ошибке?
- Как создать свое собственное сообщение об ошибке?
- Почему вы не можете использовать методы аутентификации контроллера, основанные на сессиях, если хотите позволить программно подключаться к вашему API?
- Что такое "Сервис-ориентированная архитектура"?

### Основы API

Ваше Rails-приложение на самом деле уже является API, хотя вы могли не думать о нем как об API. Веб-браузер, запускаемый вашими пользователями, также является программой, так что он фактически отправляет API-запрос вашему Rails-приложению, когда пользователь открывает новую страницу. Мы привыкли так думать потому, что рендеринг HTML-шаблонов настолько распространенная задача, что мы просто зашиваем этот функционал в наши серверные программы в качестве стандартного типа ответа, и все остальное считаем чем-то необычным.

Однако, часто вы хотите сделать запрос, который не требует переживать все головные боли от использования браузера. Вас может не заботить структура страницы (HTML), но взамен вы хотите получить чистые данные. Допустим, вы хотите получить список всех пользователей. Вы можете запросить что-то вроде `http://yourapplication.com/users`, что наверняка запустит действие `#index` и отрендерит список всех пользователей приложения.

Но зачем заморачиваться со всей этой лишней информацией, если все чего вы хотите - это получить список пользователей? Самым простым вариантом будет отправить запрос на тот же самый URL, указав ожидание JSON или XML ответа взамен. Если вы правильно настроите ваш Rails-контроллер, назад вы получите простой JSON объект-массив, содержащий всех пользователей. Прекрасно!

Тот же самый принцип применяется, когда вы общаетесь с внешним API. Скажем, вы хотите получить недавние "твиты" пользователя из Twitter. Вам потребуется лишь сообщить вашему Rails-приложению как взаимодействовать с API Twitter'а (т.е. аутентифицировать себя), отправить запрос и обработать набор "твитов", который будет возвращен.

### Создание API

Вы можете захотеть сделать ваше Rails-приложение чистым бэкенд API для фронтенд веб-страниц, или просто захотите научиться посылать JSON, когда фронтенд запрашивает его. Этот раздел не осветит как создавать полноценные RESTful API с функциями аутентификации. Это плавное введение в обращение с вашим приложением как с API.

### Основы

Если вы хотите, чтобы ваше Rails-приложение возвращало JSON вместо HTML, вам потребуется сказать вашему контроллеру, чтобы он это делал. Самое замечательное то, что одно и то же действие контроллера может возвращать различные типы в зависимости от того, делает ли ваш пользователь обычный запрос из браузера или обращается к API через командную строку. Это определяет какой тип запроса был сделан, основываясь на расширении запрашиваемого файла, например, `example.xml` или `example.json`.

Вы можете проверить, что Rails "думает" об ожидаемом вами типе файла, проверив серверный лог:

```ruby
Started GET "/posts/new" for 127.0.0.1 at 2013-12-02 15:21:08 -0800
Processing by PostsController#new as HTML
```

Первая строка говорит вам какой URL был запрошен, а вторая сообщает куда он был направлен и как Rails его обрабатывает. Если бы вы использовали расширение `.json`, то это выглядело бы так:

```ruby
Started GET "/posts.json" for 127.0.0.1 at 2013-12-04 12:02:01 -0800
Processing by PostsController#index as JSON
```

Если у вас есть запущенное тестовое приложение, попробуйте запросить различные URL. Если ваш контроллер не умеет их обрабатывать, то вы можете получить ошибку, но все равно должны видеть, что Rails понимает под вашими запросами.

### Рендеринг JSON или XML

Когда вы решите, что хотите отвечать на запросы с помощью JSON или XML, вам потребуется сообщить вашему контроллеру, что нужно рендерить JSON или XML вместо HTML. Один из способов сделать это - использовать метод `#respond_to`:

```ruby
class UsersController < ApplicationController
  def index
    @users = User.all
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render xml: @users }
      format.json { render json: @users }
    end
  end
end
```

В данном случае, `#respond_to` передает в блок объект формата, к которому вы можете приложить соответствующий вызов рендеринга. Если вы ничего не сделаете, будет рендериться html с использованием стандартного Rails-шаблона (в этом примере `app/views/index.html.erb`).

Функция `#render` достаточно умна, чтобы понять, как рендерить широкий спектр форматов. Когда вы передаете ей ключ `:json`, она вызовет `#to_json` на значении, в данном примере на `@users`. Это преобразует ваш(и) Ruby-объект(ы) в JSON-строки, которые будут переданы запрашивающему приложению.

Таким образом, вы получаете свой API. Конечно, создание API может быть немного более сложным, если вы захотите делать какие-то необычные вещи, но все держится на основах.

#### Указание возвращаемых атрибутов

Допустим, вы хотите убедиться, что не возвращаете email-адрес пользователя вместе с объектом пользователя (User). В этом случае, вы захотите изменить атрибуты, которые будут возвращаться, модифицируя то, что делает метод `#to_json`.

Раньше вы бы просто переопределили метод `#to_json` своей версией, но теперь вам это не понадобится - в действительности, вы взамен переопределите метод `#as_json`. Метод `#as_json` используется в методе `#to_json`, так что его модификация неявно изменён результат `#to_json`, но довольно специфическим способом.

`#to_json` делает 2 вещи: запускает `#as_json` и получает хэш атрибутов, которые будут отрендерены в JSON. Затем он проводит рендеринг в JSON, используя `ActiveSupport::json.encode`. Так что, модифицируя `#as_json`, вы более конкретно указываете ту часть метода `#to_json`, которую в действительности хотите изменить.

В нашем случае, мы делаем это модифицируя `#as_json` в нашей модели так, чтобы возвращать лишь необходимые нам атрибуты:

```ruby
# app/models/user.rb
class User < ActiveRecord::Base

  # Вариант 1: Полное переопределение метода #as_json
  def as_json(options={})
    { :name => self.name }  # НЕ включаем поле email
  end

  # Вариант 2: Используем стандартный метод #as_json
  def as_json(options={})
    super(only: [:name])
  end
end
```

Затем, в нашем контроллере лишь потребуется отрендерить JSON как обычно (в примере ниже всегда будет возвращаться JSON, независимо от того, был ли отправлен HTML-запрос или нет):

```ruby
# app/controllers/users_controller.rb
class UsersController < ApplicationController

  def index
    render json: User.all
  end
end
```

Заметьте, что вам не нужно самостоятельно вызывать `#to_json`, когда вы используете `#render` - он сделает это за вас.

Просмотрите [документацию по as_json](http://apidock.com/rails/ActiveModel/Serializers/JSON/as_json) для деталей и прочей информации, вроде того как включать ассоциации.

#### Рендер ошибок или пустого ответа

Иногда вы хотите просто отправить код HTTP-ошибки без какого-либо тела ответа. Интернет-сообщество постоянно спорит о том, что является лучшей практикой на этот счет (посмотрите [этот более старый блог](http://www.intridea.com/blog/2008/7/23/using-http-status-codes-for-rails-ajax-error-handling) для одного подхода и [этот ответ на StackOverflow](http://stackoverflow.com/questions/9130191/how-to-return-correct-http-error-codes-from-ruby-on-rails-application) для другого направления ответов). Вот простой пример (мы просто рендерим ошибки в любой ситуации):

```ruby
# app/controllers/users_controller.rb
class UsersController < ApplicationController
  def index
    render nothing: true, status: 404
  end
end
```

#### Создание динамических страниц ошибок

Вы можете создавать собственные страницы ошибок. Посмотрите [этот пост блога](http://wearestac.com/blog/dynamic-error-pages-in-rails).

Иногда Heroku может потребовать дополнительные шаги для корректного отображения ваших страниц с ошибками. Посмотрите [их документацию по страницам ошибок здесь](https://devcenter.heroku.com/articles/error-pages). Вам может потребоваться сперва удалить статичные страницы из директории `app/public`.

### Обеспечение безопасности извне

Допустим, вы хотите позволить обращаться к API только если пользователь залогинен. Ваша существующая аутентификация в контроллере уже делает эту работу - просто убедитесь, что у вас установлен правильный `#before_action` (например, `before_action :require_login`). Может потребоваться функционал, когда и залогиненный и не залогиненный пользователи могут просматривать страницу, но каждый должен видеть различные данные. Вы не хотите, чтобы незалогиненные пользователи имели возможность делать запросы к API для получения важных данных. Аналогично, вы не хотите давать возможность посещать определенные HTML-страницы неавторизованным пользователям.

Если вы хотите обрабатывать запросы из приложения, которое не является браузером (например, из командной строки), вы не можете полагаться на браузерные "куки" для аутентификации. Вот почему большинство API использует собственные токены как часть процесса аутентификации. Мы поговорим чуть больше о токенах в следующем уроке.

### Следующие шаги

Теперь у вас есть навыки использования вашего Rails-приложения для отдачи не только HTML, но и любого другого формата. Если вы хотите пойти дальше и позволить другим разработчикам создавать что-то с использованием вашей платформы (например, чтобы они могли делать программные запросы вместо аутентификации в качестве пользователя), вам понадобится сделать вашу API-систему намного более надежной. Мы не будем освещать все это здесь, но посмотрите следующие материалы:

- Статья [Building Awesome Rails APIs](http://collectiveidea.com/blog/archives/2013/06/13/building-awesome-rails-apis-part-1/) содержит описание множества лучших подходов для движения от игрушечного приложения в сторону стандартов промышленных API.

### Сервис-ориентированная архитектура

Пришло время представить архитектурный подход под именем "Сервис-ориентированная архитектура" (Service-Oriented Architecture, SOA). Основная идея заключается в том, что ваше приложение будет состоять из множества сервисов, вроде системы оплаты, регистрации пользователей, модуля рекомендаций и т.д. Вместо того, чтобы создавать все это внутри одного главного приложения, вы разбиваете подсистемы на полностью независимые кусочки, которые взаимодействуют друг с другом, используя внутренние API-интерфейсы.

Это хорошо по многим причинам. Благодаря тому, что каждый кусочек вашего приложения не заботится о том, как работают другие части, и знает только как запросить данные через их API, вы можете делать значительные изменения в коде сервиса, и все остальное приложение будет работать, как и прежде. Вы можете полностью заменить один сервис на другой, и, пока он взаимодействует, используя те же API-методы, это пройдет очень гладко. Вы можете использовать внешние API как часть вашего приложения (например, платежные системы) вместо написания собственного. Вы можете создать PHP-приложение, взаимодействующее с Python-приложением, взаимодействующим с Rails-приложением, и все будет работать, ведь они общаются между собой с помощью API.

Как правило, стараться делать максимально независимой каждую часть вашего приложения - хорошая идея. Концепция СОА подталкивает вас мыслить в рамках того, какие именно методы вы хотите предоставлять другим частям вашего приложения, и заодно это сделает ваш код лучше. Вдобавок, предполагая, что каждый крупный компонент вашего приложения независим, вы также сможете намного легче выделять проблемы и обрабатывать ошибки более осмысленно.

Использовать сервис-ориентированную архитектуру для целого приложения - это что-то вроде разбиения гигантского сложного Ruby-скрипта на изящные классы и методы, только в большем масштабе.

Одним из наиболее известных случаев перехода на сервис-ориентированную архитектуру является Amazon.com. Однажды в 2002 году, Джефф Безос прямо заявил, что все рабочие группы должны перейти на СОА, или будут уволены. Печально известный [пост из блога](https://plus.google.com/+RipRowan/posts/eVeouesvaVX) сотрудника Google, предназначенный внутрикорпоративных целей, но случайно ставший открытым для публики, рассказывал о мощи Amazon с использованием СОА. Это отличное чтиво, так что обязательно его оцените, но основные тезисы письма Безоса вынесены в следующие цитаты из поста:

> 1. Все команды отныне предоставляют свои данные и функциональность через интерфейсы сервисов.
>
> 2. Команды должны взаимодействовать друг с другом посредством этих интерфейсов.
>
> 3. Иные формы межпроцессного взаимодействия запрещены: никаких прямых ссылок, никакого непосредственного чтения данных другой команды, никаких моделей общей памяти, никаких "бэкдоров" и тому подобного. Единственный разрешенный способ взаимодействия - обращение к интерфейсу сервисов через сеть.
>
> 4. Неважно какую технологию они используют. HTTP, Corba, Pubsub, собственные протоколы - без разницы. Безоса это не волнует.
>
> 5. Все интерфейсы сервисов, без исключения, должны быть изначально спроектированы с возможностью управления извне. То есть, команда должна планировать и проектировать так, чтобы быть в состоянии предоставить интерфейс разработчикам вне компании. Никаких исключений.
>
> 6. Любой проигнорировавший эти требования будет уволен.

СОА - это серьезное дело. Несомненно, есть много проблем, которые всплывают при ее использовании - посмотрите [этот пост о "извлеченных уроках" Amazon](http://apievangelist.com/2012/01/12/the-secret-to-amazons-success-internal-apis/) - но она имеет невероятно много преимуществ.

Вы, наверняка, не будете сильно беспокоиться о СОА, пока создаете "игрушечные" приложения для самих себя, но этот вопрос определенно встанет перед вами, когда вы начнете работать на ИТ компанию, поэтому знакомство с ней - это хорошая практика.

### Ваша цель

1. Прочитайте раздел 7 [руководства Rails по контроллерам](http://rusrails.ru/action-controller-overview), чтобы изучить рендеринг JSON и XML.
2. Они не обязательны к просмотру (потому что они идут немного дальше, чем мы сейчас подготовлены), но, если вам интересно, взгляните на Railscasts в разделе Дополнительных ресурсов внизу урока, чтобы больше узнать о преимуществах API.

### Заключение

Мы плотнее поработаем с вашим приложением как с API во время курса по Javascript. В этом курсе вы создадите несколько полноценных (фулл-стэк) приложений, использующих AJAX-вызовы для лучшего пользовательского интерфейса, что по факту включает в себя рендеринг XML или JSON данных взамен полноценной HTML-страницы. Затем вы создадите несколько одностраничных Javascript-приложений, которые полагаются на API, предоставляемом вашим Rails-приложением, для получения всех необходимых данных из БД, а во всем остальном работающих на стороне клиента (в браузере).

Лучший способ разобраться с API - создать и взаимодействовать с ним, на чем мы сфокусируемся в наших проектах.

В следующем уроке мы осветим процесс работы с API других разработчиков, что даст дополнительную "огневую мощь" вашему собственному приложению.

### Дополнительные ресурсы

_Этот раздел содержит полезные ссылки на дополнительные материалы. Это не обязательно, так что расценивайте их как нечто полезное, если вы хотите поглубже погрузиться в тему:_

- Посмотрите [этот бесплатный Railscast о превращении вашего приложения в API](http://railscasts.com/episodes/348-the-rails-api-gem)
- Посмотрите [этот бесплатный Railscast о защите вашего API](http://railscasts.com/episodes/352-securing-an-api)
- Посмотрите [этот бесплатный Railscast о ведении версионности вашего API](http://railscasts.com/episodes/350-rest-api-versioning)
- [Создание открытого API с использованием шаблонов вьюх вместо `#to_json`](http://engineering.gomiso.com/2011/05/16/if-youre-using-to_json-youre-doing-it-wrong/)
- [`to_json` или `as_json` от Jonathan Julian](http://jonathanjulian.com/2010/04/rails-to_json-or-as_json/) предоставит особые примеры для углубления в метод `as_json`.
