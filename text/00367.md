
## Введение

Теперь мы начнем знакомство с, вероятно, самой важной темой данного курса, а именно библиотекой [React](https://reactjs.org/). Давайте начнем с создания простого приложения React и познакомимся с основными понятиями React.

Самый простой способ начать работу - использовать инструмент под названием [create-react-app](https://github.com/facebookincubator/create-react-app). Вы можете (но это не обязательно) установить <i>create-react-app</i> на вашем компьютере, если <i>npm</i>, который был установлен нами вместе с Node, имеет версию выше <i>5.3</i>.

Давайте создадим приложение <i>part1</i> с помощью <i>create-react-app</i> и перейдем в папку приложения.

```bash
$ npx create-react-app part1
$ cd part1
```

С этого момента каждая команда, начинающаяся с символа <em>$</em>, должна быть введена вами в командной строке терминала. Символ <em>$</em> вводить не нужно, поскольку он представляет собой [приглашение](https://pingvinus.ru/note/bash-promt).

Приложение запускается следующим образом:

```bash
$ npm start
```

По умолчанию приложение стартует на локальному порту 3000 с адресом <http://localhost:3000>

Chrome должен запуститься автоматически. **Обязательно** откройте консоль браузера и откройте текстовый редактор, чтобы вы могли одновременно просматривать и код и веб-страницу:

![](https://raw.githubusercontent.com/vectree/resources/master/images/00028.svg?raw=true)

Код приложения находится в папке <i>src</i>. Давайте упростим стартовый код, изменив содержимое файла <i>index.js</i>:

```js
import React from 'react'
import ReactDOM from 'react-dom'

const App = () => (
  <div>
    <p>Hello world</p>
  </div>
)

ReactDOM.render(<App />, document.getElementById('root'))
```

Файлы <i>App.js</i>, <i>App.css</i>, <i>App.test.js</i>, <i>logo.svg</i> и <i>serviceWorker.js</i> можно удалить, поскольку они сейчас нам не нужны.

### Компонент

Теперь файл <i>index.js</i> определяет React-[компонент](https://ru.reactjs.org/docs/components-and-props.html) с именем <i>App</i>. и команда последней строки

```js
ReactDOM.render(<App />, document.getElementById('root'))
```

отображает его содержимое в элемент <i>div</i>, определенный в файле <i>public/index.html</i> и имеющий значение атрибута <i>id</i> равное 'root'.

По умолчанию файл <i>public/index.html</i> пуст. Вы можете попробовать добавить свой HTML в файл. Однако при использовании React весь контент, который необходимо отобразить, обычно определяется в компонентах React.

Давайте подробнее рассмотрим код, определяющий компонент:

```js
const App = () => (
  <div>
    <p>Hello world</p>
  </div>
)
```

Как вы, наверное, догадались, компонент будет отрисован в виде тега <i>div</i>, который содержит тег <i>p</i>, содержащий текст <i>Hello world</i>.

Технически компонент определяется как функция JavaScript. Ниже приведена функция, в которую не передаются параметры:

```js
() => (
  <div>
    <p>Hello world</p>
  </div>
)
```

Затем эта функция присваивается константе <i>App</i>:

```js
const App = ...
```

Есть несколько способов определить функцию в JavaScript. Здесь мы будем использовать [стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions), которые описаны в более актуальной версии JavaScript, известной как [ECMAScript 6](http://es6-features.org/#Constants) или ES6.

Поскольку функция состоит только из одного выражения, мы использовали сокращение, которое по сути скрывает в себе этот фрагмент кода:

```js
const App = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
```

Другими словами, функция возвращает значение выражения.

Функция, определяющая компонент, может содержать любой код JavaScript. Измените ваш компонент следующим образом и проверьте, что произошло в консоли:

```js
const App = () => {
  console.log('Hello from component')
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
```

Кроме того есть возможнось отображать динамический контент внутри компонента.

Измените компонент следующим образом:

```js
const App = () => {
  const now = new Date()
  const a = 10
  const b = 20

  return (
    <div>
      <p>Hello world, it is {now.toString()}</p>
      <p>
        {a} plus {b} is {a + b}
      </p>
    </div>
  )
}
```

Любой код JavaScript в фигурных скобках выполняется, и результат этого выполнения встраивается в указанное место HTML, созданного компонентом.

### JSX

Кажется, что компоненты React возвращают HTML-разметку. Тем не менее, это не так. Структура React-компонент в основном пишется с использованием [JSX](https://ru.reactjs.org/docs/introducing-jsx.html). Хотя JSX выглядит как HTML, на самом деле мы имеем дело с методом написания JavaScript. JSX, возвращаемый компонентами React, компилируется (преобразуется) в JavaScript.

После компиляции наше приложение выглядит так:

```js
import React from 'react'
import ReactDOM from 'react-dom'

const App = () => {
  const now = new Date()
  const a = 10
  const b = 20
  return React.createElement(
    'div',
    null,
    React.createElement(
      'p', null, 'Hello world, it is ', now.toString()
    ),
    React.createElement(
      'p', null, a, ' plus ', b, ' is ', a + b
    )
  )
}

ReactDOM.render(
  React.createElement(App, null),
  document.getElementById('root')
)
```

За компиляцию отвечает [Babel](https://babeljs.io/repl/). Проекты, созданные с помощью *create-react-app*, уже настроены для автоматической компиляции. Подробнее об этой теме мы поговорим в 7 части этого курса.

Конечно, есть возможность писать на React, используя "чистый JavaScript" без использования JSX. Хотя, никто в здравом уме не сделает этого.

На практике JSX очень похож на HTML, с той лишь разницей, что в JSX вы можете легко встраивать динамический контент, написав соответствующий JavaScript-код в фигурных скобках. Идея JSX очень похожа на языки шаблонов, такие как Thymeleaf, используемые в Java Spring на серверах.

JSX - это [XML](https://developer.mozilla.org/ru/docs/Web/XML/XML_introduction), а значит каждый тег должен быть закрыт. Например, новая строка - это пустой элемент, который в HTML можно записать следующим образом:

```html
<br>
```

но при написании JSX тег должен быть закрыт:

```html
<br />
```

### Множество компонент

Давайте изменим приложение следующим образом (примечание: здесь и далее все импорты в верхней части <i>примеров</i> не будут показаны, но они все еще необходимы для работы кода):

```js
// highlight-start
const Hello = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
// highlight-end

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello /> // highlight-line
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

Мы определили новый компонент <i>Hello</i> и использовали его внутри компонента <i>App</i>. Естественно, компонент может использоваться несколько раз:

```js
const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello />
      // highlight-start
      <Hello />
      <Hello />
      // highlight-end
    </div>
  )
}
```

Написание компонент с помощью React - легко, а благодаря возможности комбинирования компонент сложное приложение становится более поддерживаемым. И действительно, основная философия React - создание приложений из множества специализированных повторно используемых компонент.

Другим строгим соглашением является имя <i>App</i> для <i>root-компонента</i> - компонента в верхней части дерева приложения. Тем не менее, как мы узнаем из 6 части курса, существуют ситуации, когда компонент <i>App</i> не является корнем, а заключен в соответствующий служебный компонент.

### props: пробрасываем данные в компоненты

Можно передавать данные в компоненты с помощью так называемых [пропсов](https://ru.reactjs.org/docs/components-and-props.html).

Давайте изменим компонент <i>Hello</i> следующим образом:

```js
const Hello = (props) => { // highlight-line
  return (
    <div>
      <p>Hello {props.name}</p> // highlight-line
    </div>
  )
}
```

Теперь функция, определяющая компонент, имеет параметр <i>props</i>. В качестве аргумента параметр получает объект, у которого есть поля, соответствующие всем "пропсам", которые определяет пользователь компонента.

Пропсы задаются следующим образом:

```js
const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="George" /> // highlight-line
      <Hello name="Daisy" /> // highlight-line
    </div>
  )
}
```

В коде может быть любое количество пропсов, и их значения могут быть "жестко заданными" строками или же результатами выполнения JavaScript. Если значение пропса вычисляется с помощью JavaScript, оно должно быть заключено в фигурные скобки.

Давайте изменим код так, чтобы компонент <i>Hello</i> использовал два пропса:

```js
const Hello = (props) => {
  return (
    <div>
      <p>
        Hello {props.name}, you are {props.age} years old // highlight-line
      </p>
    </div>
  )
}

const App = () => {
  const name = 'Peter' // highlight-line
  const age = 10       // highlight-line

  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} /> // highlight-line
      <Hello name={name} age={age} />     // highlight-line
    </div>
  )
}
```

Пропсы, переданные компонентом <i>App</i> являются значениями переменных, результатом вычисления суммы и обычной строкой.

### Пару заметок

React сконфигурирован для генерации довольно четких и понятных сообщений об ошибках. Несмотря на это, в начале вам следует, продвигаться **очень маленькими шагами** и убедиться, что каждое изменение работает как нужно.

**Консоль всегда должна быть открыта**. Если браузер сообщает об ошибках, не пишите больше код, надеясь на чудо. Вместо этого попытайтесь понять причину ошибки и, например, вернитесь к предыдущему состоянию кода:

![](https://raw.githubusercontent.com/vectree/resources/master/images/00029.png?raw=true)

Не забывайте, что в React можно и нужно использовать команду <em>console.log()</em> (она выводит текст в консоль) в вашем коде.

Также имейте в виду, что **имена React-компонент должны быть заглавными**. Если вы попытаетесь определить компонент следующим образом:

```js
const footer = () => {
  return (
    <div>
      greeting app created by
      <a href="https://github.com/mluukkai">mluukkai</a>
    </div>
  )
}
```

и использовать его так:

```js
const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} />
      <footer /> // highlight-line
    </div>
  )
}
```

страница не будет отображать содержимое, определенное в компоненте Footer, и вместо этого React создает пустой элемент <i>footer</i>. Если вы измените первую букву имени компонента на заглавную, то React создаст элемент <i>div</i>, определенный в компоненте Footer, и отрисует его.

Обратите внимание, что содержимое компонента React (обычно) должно содержать **один корневой элемент**. Если мы, например, попытаемся определить компонент <i>App</i> без внешнего <i>div</i>-элемента:

```js
const App = () => {
  return (
    <h1>Greetings</h1>
    <Hello name="Maya" age={26 + 10} />
    <Footer />
  )
}
```

то мы получим ошибку:

![](https://raw.githubusercontent.com/vectree/resources/master/images/00030.png?raw=true)

Использование корневого элемента - не единственный верный вариант. <i>Массив</i> компонент также является допустимым решением:

```js
const App = () => {
  return [
    <h1>Greetings</h1>,
    <Hello name="Maya" age={26 + 10} />,
    <Footer />
  ]
}
```

Тем не менее, при определении корневого компонента приложения это не особо разумно, и делает код немного страннмм и уродливым.

Поскольку корневой элемент задан, у нас есть "лишние" div-элементы в DOM-дереве. Этого можно избежать, используя [фрагменты](https://ru.reactjs.org/docs/fragments.html) - оборачивая элементы, возвращаемые компонентом, в пустой элемент:

```js
const App = () => {
  const name = 'Peter'
  const age = 10

  return (
    <>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} />
      <Hello name={name} age={age} />
      <Footer />
    </>
  )
}
```

Теперь все успешно компилируется, и DOM, сгенерированный React, больше не содержит лишний div-элемент.
