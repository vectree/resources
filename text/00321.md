## Безопасность

### Безопасность веб-приложений

Есть плохие люди, которые могут и хотят взломать ваши веб-приложения. Важно принять необходимые меры предосторожности, чтобы укрепить безопасность вашего приложения. К счастью, прекрасные люди в [The Open Web Application Security Project][1] (OWASP) составили полный список известных проблем безопасности и методов защиты от них. Это должно быть прочитано любым разработчиком, заботящимся о безопасности.

* [Прочитать руководство по безопасности OWASP][2]

[1]: https://www.owasp.org/
[2]: https://www.owasp.org/index.php/Guide_Table_of_Contents

### Хэширование паролей

Наверное, каждый PHP-разработчик занимается разработкой приложений, которые нуждаются в пользовательской авторизации. Имя пользователя и пароль хранятся в базе данных и позже используются для авторизации пользователя.

Очень важно правильно [_хэшировать_][3] пароль перед его сохранением. Хэширование пароля является необратитым, односторонняя функция применяется на пользовательских паролях. Она возвращает строку определенной длины, которую невозможно расшифровать. Это значит, что вы можете сравнить один хэш с другим, чтобы понять, что они пришли из одной и той же исходной строки, но вы не можете определить оригинальную строку. Если ваши пароли не захэшированы, и доступ к базе данных получен третьй стороной, то ваши пользовательские аккаунты теперь скомпрометированы. Некоторые пользователи (к сожалению) могут использовать один и тот же пароль для разных сервисов. Как бы то ни было, очень важно серьезно относиться к безопасности.

**Хэширование паролей с функцией `password_hash`**

В PHP 5.5 была представлена функция `password_hash`. Сейчас она использует BCrypt, сильнейший алгоритм, поддерживаемый PHP. Она будет обновлена в будущем, для поддержки бОльшего числа алгоритмов, по мере необходимости. Библиотека `password_compat` была создана для обратной совместимости с PHP >= 5.3.7.

Ниже мы хэшируем строку и далее сверяем её с новой строкой. Поскольку наши две исходные строки отличаются ('secret-password' и 'bad-password') эта авторизация будет неудачной.

```php
<?php

require 'password.php';

$passwordHash = password_hash('secret-password', PASSWORD_DEFAULT);

if (password_verify('bad-password', $passwordHash)) {
    //Правильный пароль
} else {
    //Неправильный пароль
}
```



* [Подробнее о `password_hash`] [1]
* [`password_compat` для PHP  >= 5.3.7 && < 5.5] [2]
* [Подробнее о хэшировании в отношении криптографии] [3]
* [PHP `password_hash` RFC] [4]

[1]: http://us2.php.net/manual/ru/function.password-hash.php
[2]: https://github.com/ircmaxell/password_compat
[3]: http://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F
[4]: https://wiki.php.net/rfc/password_hash

### Фильтрация данных

Никогда не доверяйте пользовательскому вводу, который передаётся вашему PHP коду. Всегда проверяйте и очищайте пользовательский ввод перед его использованием в коде. Функции `filter_var` и `filter_input` помогут очистить переменные, а также проверить соответствие введённых данных некоторому формату (например, адрес электронной почты).

Пользовательский ввод может быть различным: `$_GET` и `$_POST`, данные введённые в форму, некоторые значения в суперглобальной переменной `$_SERVER` и тело HTTP запроса, открытое с помощью `fopen('php://input', 'r')`. Запомните, что пользовательский ввод не ограничивается данными формы, отправленной пользователем. Отправляемые и загружаемые файлы, значения сессий, данные cookie и данные сторонних веб-сервисов также приравниваются к пользовательскому вводу.

Хотя пользовательские данные могут быть без проблем сохранены, скомбинированы и к ним может быть получен доступ позже, они всё ёще являются пользовательским вводом. Каждый раз, когда вы что-либо обрабатываете, объединяете или подключаете данные в ваш код, спросите себя, отфильтрованы ли эти данные и можно ли им доверять.

Данные могут быть _отфильтрованы_ по-разному, в зависимости от их назначения. Например, когда нефильтрованные данные, введённые пользоватем, передаются в HTML код страницы, он может выполнить HTML и JavaScript на вашем сайте! Этот тип атаки известен, как Cross-Site-Scripting (XSS) и может иметь очень серьёзные последствия. Один из способов избежать XSS заключается в очистке ввода от всех HTML тэгов (их удалением, или заменой на HTML символы) с помощью функции `strip_tags` или экранирование символов в равносильные им HTML сущности с функцией `htmlentities` или `htmlspecialchars`.

Другой пример, передача данных для выполнения командной строкой. Это может быть крайне опасно (и, как правило &mdash; это плохая идея), но вы можете использовать встроенную функцию `escapeshellarg` для очистки аргументов командной строки.

Последний пример, принимает пользовательский ввод, чтобы определить, какой файл загружать из файловой системы. Это может быть использовано для изменения имени файла на путь файла. Вам нужно убрать "/", "../", [нулевые байты][6] или другие символы из пути файла, так чтобы скрипт не мог загружать скрытые, непубличные или конфиденциальные файлы.

* [Подробнее о фильтрации данных][1]
* [Подробнее о функции `filter_var`][4]
* [Подробнее о функции `filter_input`][5]
* [Подробнее об обработке нулевых байтов][6]

#### Санитизация

Санитизация удаляет (или экранирует) неправильные или небезопасные символы из пользовательского ввода.

Например, вам необходимо нормализовать пользовательский ввод перед подключением ввода в HTML или
его вставкой в сырой SQL запрос. Когда вы используете связанные параметры с [PDO](#databases),
они будут очищать ввод за вас.

Иногда требуется разрешить некоторые безопасные HTML тэги в вводе, когда он подключается в HTML
страницу. Это очень трудно сделать и многие избегают этого, используя ограниченное форматирование,
как например Markdown или BBCode, либо библиотеки с белым списком, как [HTML Purifier][html-purifier],
существующие по этой причине.

[Санитизационные фильтры][2]

#### Валидация

Валидация гарантирует, что пользовательский ввод, является тем, что вы ожидаете. Например, вы
можете валидировать адрес электронной почты, номер телефона или возраст при обработке запроса
регистрации.

[Валидационные фильтры][3]

[1]: http://www.php.net/manual/ru/book.filter.php
[2]: http://www.php.net/manual/ru/filter.filters.sanitize.php
[3]: http://www.php.net/manual/ru/filter.filters.validate.php
[4]: http://php.net/manual/ru/function.filter-var.php
[5]: http://www.php.net/manual/ru/function.filter-input.php
[6]: http://php.net/manual/ru/security.filesystem.nullbytes.php
[html-purifier]: http://htmlpurifier.org/

### Конфигурационные файлы

Когда вы создаёте файлы конфигурации для ваших приложений, рекомендуется использование одного из следующих способов:

- Рекомендуется хранить вашу конфигурационную информацию там, где к ней не может быть получен доступ напрямую, а доступ к ней осуществлялся через файловую систему.
- Если вы вынуждены хранить конфигурационные файлы в корневом каталоге, именуйте файл с расширением `.php`. Это гарантирует, что, если к скрипту обратятся напрямую, он не будет выведен, как обычный текст.
- Информация в файлах конфигурации, должна быть защищена соответственно, либо с помощью шифрования или системных прав группы/пользователя файла.

### Использование глобальных переменных

**Примечание:** С появлением PHP 5.4 директива `register_globals` была удалена и больше не может быть использована. Это касается тех, кому нужно обновить старое приложение.

Включенный параметр конфигурации `register_globals` делает несколько типов переменных (в том числе из `$_POST`, `$_GET` и `$_REQUEST`) глобальными, доступными в глобальной области видимости вашего приложение. Это может легко привести к проблемам с безопасностью, поскольку ваше приложение не сможет эффективно определить откуда пришли данные.

Например : `$_GET['foo']` будет доступна через `$foo`, которая может заместить переменную, которая не была объявлена. Если вы используете PHP < 5.4.0 __убедитесь__ что `register_globals` __off__ (выключена).

* [Register_globals в руководстве PHP](http://www.php.net/manual/ru/security.globals.php)

### Сообщения об ошибках

Логирование ошибок полезно при поиске проблемных мест вашего приложения, также логирование может выдать информацию о структуре вашего приложения. Для эффективной защиты вашего приложения от проблем, которые могут быть вызваны выводом этих сообщений, вам необходимы различные настройки сервера для разработки и продакшна.

#### Разработка

Для того, чтобы видеть все возможные ошибки во время <strong>разработки</strong>, настройте следующие параметры в вашем `php.ini`:

    display_errors = On
    display_startup_errors = On
    error_reporting = -1
    log_errors = On

> Установка значения в `-1` покажет каждую возможную ошибку, даже если новые уровни и константы будут добавлены в новых версиях PHP. Константа `E_ALL` ведёт себя так-же в PHP 5.4. &mdash; [php.net](http://php.net/manual/function.error-reporting.php)

Константа уровня ошибок `E_STRICT` была введена в 5.3.0 и не является частью `E_ALL`, как бы то ни было, она стала частью `E_ALL` в 5.4.0 Что это значит? Для вывода всех возможных ошибок в версии 5.3 вам нужно использовать либо `-1` либо `E_ALL | E_STRICT`.

**Вывод всех ошибок разными версиями PHP**

* &lt; 5.3 `-1` or `E_ALL`
* &nbsp; 5.3 `-1` or `E_ALL | E_STRICT`
* &gt; 5.3 `-1` or `E_ALL`

#### Продакшн

Чтобы спрятать все ошибки вашей среды во время <strong>продакшна</strong>, настройте ваш `php.ini` следующим образом:

    display_errors = Off
    display_startup_errors = Off
    error_reporting = E_ALL
    log_errors = On

С этими настройками в продакшне, ошибки всё также будут записываться в лог ошибок веб сервера, но не будут показаны пользователю. Для подробной информации об этих настройках, смотрите руководство PHP:

* [error_reporting](http://php.net/manual/errorfunc.configuration.php#ini.error-reporting)
* [display_errors](http://php.net/manual/errorfunc.configuration.php#ini.display-errors)
* [display_startup_errors](http://php.net/manual/errorfunc.configuration.php#ini.display-startup-errors)
* [log_errors](http://php.net/manual/errorfunc.configuration.php#ini.log-errors)