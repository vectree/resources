# Проект: Основы маршрутов, представлений и контроллеров

### На разогрев: Передача параметров через RestClient

В этом проекте вы попробуете посылать запросы в приложение Rails вручную, используя командную строку. Для начала вы создадите очень простое приложение Rails (попрактикуясь в шагах его создания), а затем простой скрипт, использующий гем RestClient (который вы использовали в первом проекте) для посылки запросов и анализа полученных от сервера ответов.

Предстоит выполнить много шагов, но они достаточно просты.

### Ваше задание

#### Основа приложения

Сначала необходимо создать простое приложение Rails:

1. Создайте новое приложение Rails "rest-tester" (помните команду `$ rails new`?). Перейдите в папку приложения, используя команду `cd`, и откройте ее в текстовом редакторе.
2. Начнем с создания маршрутов для пользователей. Откройте файл `config/routes.rb` и добавьте строчку `resources :users`.
3. Вопрос: Какие при этом маршруты были созданы (их 7)? Попробуйте назвать все эти действия и пояснить, для чего они нужны. Вспомните методы HTTP и URL'ы, которые соответствуют созданным маршрутам (не забывайте, что некоторые маршруты используют одинаковый URL, но для них есть различие в HTTP методе).
4. Проверьте себя, спользовав команду `$ rake routes`

#### Скрипт тестирования

Создайте файл, скрипт внутри которого будет запускать RestClient, и позволит вам "пинговать" ваше приложение:

5. Создайте пустой файл `app/script/rest_requestor.rb`. Наверняка для этого вам придется создать новую папку. Эта папка `script` - просто удобное место для хранения наших скриптов, которые мы будем выполнять из командной строки - в этом нет ничего особенного.
6. Каков же простейший путь создать запрос? Используйте метод `#get` приложения `rest-client` и выведите данные на экран с помощью метода `#puts`:

    ```ruby
    # app/script/rest_requestor.rb
    require 'rest-client'
    url = "http://localhost:3000"
    puts RestClient.get(url)
    ```

7. Если хотите поэкспериментировать, используйте методы `#gets` и `#chomp`, чтобы вводить параметры самостоятельно из командной строки.

#### Отсылка запросов

1. Запустите скрипт командой `$ ruby app/script/rest_requestor.rb` из каталога с приложением. Ошибка! Как оказалось, наш запрос никто не ожидает.
2. Нам необходимо запустить сервер Rails. Откройте новое окно терминала, перейдите в папку приложения и выполните `$ rails server`.
3. Запустите скрипт снова. В ответ вы должны получить HTML код дефолтной домашней страницы Rails.
4. Измените скрипт, перенаправив его на `http://localhost:3000/users`. Запустите его еще раз.
5. Теперь вы должны получить другую ошибку, что-то вроде `404 Resource Not Found`. Приложение выдало ошибку, но почему? Перейдите в окно с запущенным сервером и посмотрите лог. В его начале вы должны увидеть `ActionController::RoutingError (uninitialized constant UsersController):`. Это говорит о том, что приложение ищет контроллер - а таковой у нас отсутствует.
6. Создайте пустой контроллер для пользователей. Вы можете создать файл `app/controllers/users_controller.rb` вручную (только не забудьте унаследовать контроллер от `ApplicationController`), а можете использовать команду-генератор (которая создаст несколько файлов сразу). Выполните `$ rails generate controller Users`. Эта команда сгенерирует файлы javascript/css, файлы для тестирования приложения, а также папку `app/views/users` для хранения представлений. Чтобы не создавать файлы тестирования, можно добавить `--no-test-framework` в конце строки команды-генератора.
7. Запустите скрипт снова. Опять ошибка! Смотрим снова логи, и видим `AbstractController::ActionNotFound (The action 'index' could not be found for UsersController):`. Судя по логам, ваш запрос был маршрутизирован в контроллер, и, метод `GET` в URL `/users` URL ищет действие `#index`, но не может найти, так как такой метод нами еще не создан.
8. Создайте 4 метода, которые относятся к запросам GET. Каждый из них должен создавать переменную экземпляра для отображения имени метода:

```ruby
    # app/controllers/users_controller.rb
    ...
    def index
        @name = "Я действие Index!"
    end
    ...
```

9. Запустите скрипт еще раз. И снова ошибка. Теперь сервер говорит `ActionView::MissingTemplate (Missing template users/index...`. Выглядит как ошибка представления. И, конечно, мы знаем, что после выполнения действия, контроллер ищет для рендеринга файл `app/views/users/index.html.erb`.
10. Исправьте это, создав файл представления для каждого из четырех необходимых нам действий. Поместите названия действий в тэги `<h1>`, например:

    ```ruby
        # app/views/users/index.html.erb
        <h1><%= @name %></h1>
    ```

11. Перезапустите скрипт, и... УРА! Мы видим какой-то HTML. Большинство кода идет из макета `app/views/layouts/application.html.erb`, включая кучу вызовов `turbolinks`, но в конце вы видите ваш одинокий тэг `<h1>`. Получилось!
12. Посмотрите на файл `app/views/layouts/application.html.erb` и добавьте произвольные HTML тэги перед и после `<%= yield %>`. Запустите скрипт еще раз и посмотрите, где они отобразятся в возвращенном сервером HTML.
13. Измените скрипт, добавив остальные 3 запроса GET. Для тех запросов, которые работают с уникальными ресурсами (например `#show`), включите значение ID в URL (которое на самом деле мы использовать не будем).

#### Не-GET запросы

14. Создайте в контроллере действие `#create`, которое будет доступно при использовании запроса POST. Добавьте в скрипт простой запрос `#post`, не отсылающий данные, например `RestClient.post(url,"")`. Для понимания принципов построения не-GET запросов посмотрите [документацию](https://github.com/rest-client/rest-client).
15. Ошибка! Смотрим лог сервера - `ActionController::InvalidAuthenticityToken (ActionController::InvalidAuthenticityToken):`. Ага! Rails не принимает POST запросы из командной строки, так как обычно такие запросы содержат данные из форм, а на такого рода информацию накладываются особые ограничения. То же самое относится к запросам DELETE и PATCH.

Мы разберем это подробнее в уроке о формах, но принцип таков - Rails посылает специальный код-маркер при рендеринге формы на веб-странице, и принимает ответ только если форма отсылает этот маркер в ответ. При посылке запроса из командной строки у вас нет этого маркера, и Rails не примет запрос.

Надеемся, этот урок был полезен для изучения на практике циклов запросов в приложении Rails, и дал вам шанс поближе познакомиться с созданием приложения, его настройкой и маршрутизацией.

### Проект: Учебник Ruby on Rails

В этой главе вы будете создавать приложение с использованием CSS фреймворка Twitter Bootstrap. Если вы себя чувствуете неуверенно с CSS, вернитесь к [курсу CSS](/basics-of-web-development/html-and-css-basics).

Bootstrap возьмет на себя много задач - вместо того, чтобы думать о том, как заставить панель навигации прижаться к верху экрана, вы просто присвоите нужный класс блоку `<div>`, и стили Bootstrap реализуют это. Это хороший способ быстро получить неплохо выглядящее и работающее приложение. В курсе HTML и CSS у вас будет шанс разработать свой собственный CSS фреймворк, но сейчас хорошим выбором будет Bootstrap.

### Ваши задания

1. Выполните [Главу 5 Учебника Rails](https://ddagar.gitbooks.io/web-method/content/zapolnenie_shablona) "Заполнение шаблона".

### Дополнительные ресурсы

*Этот раздел содержит полезные ссылки на дополнительные материалы. Это не обязательно, так что расценивайте их как нечто полезное, если вы хотите поглубже погрузиться в тему:*

* [Документация по текущей версии Bootstrap](http://getbootstrap.com/) (НЕ использована в этом учебнике)
* [Документация по Bootstrap, версии 2.3](http://getbootstrap.com/2.3.2/) (использована в учебнике)
* [документация по RestClient](https://github.com/rest-client/rest-client)
* [Создание маршрутов, контроллеров и представлений в Rails от CodeLearn](http://www.codelearn.org/ruby-on-rails-tutorial/introducing-controller-view-routes)