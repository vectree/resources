# Проект: Продвинутые базовые элементы Ruby

_Не забывайте использовать Git для фиксации изменений в ваших проектах!_

### Проект 1: Сортировка пузырьком

Алгоритмы сортировки обычно изучаются в начале обучения Информационных технологиям. Их важность возможно неочевидна, но нетрудно себе представить ситуации, в которых компьютеру необходимо сортировать большие массивы данных во время ежедневных операций.
Один из самых простых (но и наиболее ресурсоемких) способов отсортировать элементы массива - это **сортировка пузырьком**, при которой каждый элемент сравнивается с соседним, и они меняются местами, если элемент справа больше чем слева. Это продолжается до тех пор, пока массив не будет отсортирован.
Посмотрите [видео Гарвардского курса CS50x про пузырьковую сортировку](http://cs50.tv/2012/fall/shorts/bubble_sort/bubble_sort-720p.mp4).
Также есть [статья об этом методе сортировки на Википедии](https://ru.wikipedia.org/wiki/Сортировка_пузырьком), на которую стоит взглянуть.

![Bubble Sort](http://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)

### Ваше задание

1. Реализовать метод `#bubble_sort` который принимает массив и возвращает отсортированный массив. Необходимо использовать сортировку пузырьком (использовать `#sort` довольно бессмысленно, не так ли?)

```
> bubble_sort([4,3,78,2,0,2])
=> [0,2,2,3,4,78]
```

2. Теперь реализуйте метод `#bubble_sort_by`, который также сортирует массив, но принимает блок. Блок должен принимать два аргумента, которые представляют собой два сравниваемых элемента. Результат выполнения блока будет подобен оператору `<=>` о котором вы узнали ранее - если результат отрицательный, то слева находится элемент который "меньше" чем справа, `0` означает что элементы равны, пололжительный результат означает, что элемент слева "больше" чем справа. Используйте это для сортировки массива.

```
> bubble_sort_by(["hi","hello","hey"]) do |left,right|
>   right.length - left.length
> end
=> ["hi", "hey", "hello"]
```

### Проект 2: методы перечисления

Вы читали про модуль `Enumerable` который "подмешивается" в массивы и хеши (а также в другие классы) и предоставляет вам множество полезных методов-итераторов. Чтобы убедиться, что в этих методах нет никакой "магии", вам стоит написать свои реализации этих методов.

### Ваше задание:

1. Создайте файл скрипта для хранения своих методов и запуска в IRB.
2. Добавьте несколько методов в этот файл для расширения существующего модуля `Enumerable`. Ruby позволяет сделать это, так как любой класс или модуль может быть без проблем расширен... Просто попробуйте что-то вроде

```
module Enumerable
  def my_each
    # ваш код
  end
end
```

1. Реализуйте метод `#my_each`, который действует так же как и `#each`, но (естественно), не используя `#each`. Вам следует помнить выражение `yield`. Убедитесь что ваш метод возвращает то же самое что и `#each`.
2. Реализуйте метод `#my_each_with_index` с такими же условиями.
3. Реализуйте `#my_select` так же, можно использовать в реализации метод `#my_each`, но не оригинальный `#each`
4. Реализуйте `#my_all?`
5. Реализуйте `#my_any?`
6. Реализуйте `#my_none?`
7. Реализуйте `#my_count`
8. Реализуйте `#my_map`
9. Реализуйте `#my_inject`
10. Проверьте свой метод `#my_inject`, создав свой метод `#multiply_els`, который перемножает все элементы массива с помощью `#my_inject`, например `multiply_els([2,4,5]) #=> 40`
11. Измените свой метод `#my_map` чтобы он принимал proc
12. Измените свой метод `#my_map` чтобы он принимал как блок так и proc, вычисляя блок только если переданы и тот и другой (в этом случае метод должен вычислять и блок и proc)

**Советы**

- Вспомните методы `yield` и `#call`.
